# Стани богат

Това е следващото голямо упражнение, което правим на школата за Мобилни приложения в ПЧМГ.
Целта е да направим приложение "Стани богат", с което потребителят може да играе известната игра. 

# Дизайн
Под дизайн имаме предвид не само графичен дизайн, а и дизайн на екраните, дизайн на правилата на играта, дизайн на кода. 
## Скелет на екраните
Първото нещо което трябва да направим е да уточним как ще изглежда нашето приложение. Решихме да работи ориентирано хоризонтално (landscape).

![Wireframes](./wireframe.png "Wireframe")


1. Начален екран, от който можем да пуснем играта, да видим най-добрия резултат до момента и въведение в това как се играе
2. Екран с въпрос. 
  1. На него виждаме въпроса с четирите възомжни отговора. 
  1. Имаме три жокера - 50:50, помощ от публиката и смяна на въпроса. 
  2. На този екран ще се показва също така на кой от въпросите сме. Напр. въпрос 3 от 15. 
  3. Ще можем да споделим въпроса в социална медия.
  4. Ще можем да се откажем.
  5. При избор на отговор ще излиза диалогов прозорец, който приканва потребителя да потвърди решението си
1. Финален екран
  1. показваме резултата "Ти спечели ..."
  2. Бутон за споделяне на резултата в социална медия
  3. Бутон за започнаве на нова игра
  4. Бутон за отиване в началото

## Правила
1. Всеки от жокерите ще може да се използва по веднъж;
2. Ако играчът се откаже на въпрос взима сумата от миналия въпрос;
3. При грешен отговор взима последната сигурна сума (сумата от 5тия или 10тия въпрос)

## Изисквания към кода
Към софтуера ще имаме следните изисквания:

1. Въпросите да са разделени в три категории - лесни (от където ще се избират въпроси от 1 до 5), средни (за въпроски от 5 до 10) и трудни (за въпроси от 10 до 15).
2. Въпросите от всяка категория се избират по случаен начин
3. Добавянето на нови въпроси да става лесно.

# Да направим потребителския интерфейс


## Хоризонтална ориентация (landscape)
Разбрахме се, че искаме приложението да бъде в landscape режим само. Т.е. искаме да го заключим в този режим и (както при повечето игри) да не може да се променя.
Дори и да не знам как да направя приложението да работи само в хоризонтален режим мога да го разбера лесно като потъся в гугъл "android landscape oreintation only".  Първият резултат сочи към [този пост](http://stackoverflow.com/questions/8408197/android-landscape-only-orientation)

Изисква се да добавим ```android:screenOrientation="landscape"``` към всяко Activity.
Така ще имаме например
```
<activity
    android:name=".MainActivity"
    android:screenOrientation="landscape">
```

### Как да завъртим емулатора хоризонтално
Сега проблемът е, че като пуснем приложението емулаторът е вертикален. За да разберем как да го завъртим, търсим в гугъл ```android emulator landscape``` и първият резултат е [това](http://stackoverflow.com/questions/2618967/switching-to-landscape-mode-in-android-emulator).
Т.е. с Ctr + F11 можем да завъртаме емулатора.


## Как бутоните за възможни отговори да променят вида си като си кликнати?
Искаме, когато бутон е кликнат той да се променя по някакъв начин, например да сменя цвета си. Това сме го виждали в много приложения. Конкретно за "Стани богат" имаме екран с въпрос и възможни отговори. Когато цъкнем на някой от отговорите, искаме той да стане напр. зелен, за да покаже, че това е избраният отговор. 

За целта ще използваме селектор (selector). 
Нека имаме следния бутон "Pesho" в xml-а на активитито.
```xml
<Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Pesho"
        android:background="@drawable/pesho_selector"
        android:onClick="peshoClicked"/>
```
Също в папката drawable имаме файла ```pesho_selector.xml``` със съдържание:
```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@drawable/pesho_pressed"
        android:state_selected="true"></item>

    <item android:drawable="@drawable/pesho_released"
        android:state_selected="false"></item>

</selector>
```
И също в папката drawable имаме две картиники pesho_pressed.png и pesho_released.png - първата е картинката на избран бутон, а втората - на неизбран бутон.

И в activity-то, в което е бутона имаме:
```java
public void peshoClicked(View v) {
    if(v.isSelected()) {
        v.setSelected(false);
    } else {
        v.setSelected(true);
    }
}
```

Сега ще се случва следното: Когато опрационната система Андроид се чуди кой фон (backgrond) да сложи на бутона ще отвори файлът ```pesho_selector``` и там от там, ще види ще ако състоянието (state) на бутона е selected трябва да покаже картинката ```@drawable/pesho_pressed"```. Това става с кода
```xml
 <item android:drawable="@drawable/pesho_pressed"
        android:state_selected="true"></item>
```
В противен случай трябва да покаже картинката ```@drawable/pesho_released```

Когато потребителят кликне бутона ще се включи фукнцията ```peshoClicked(View v)```, която ще провери дали бутонът Пешо е селектиран. Ако не е селектиран ще го селектира, и обратното. Т.е. като се кликне на бутона ще се промени състението му от селектиран на неселектиран и обратното.

## Как бутоните за жокери да стават неактивни 
Към бутноите за жокери има две изисквания:

1. Като се натиснат веднъж да стават неактивни, т.е. да не могат да се кликнат втори път
2. Като се наективни да се променя бутона (примерно да посивява), за да разбира потребителя, че бутонът е неактивен

Нека имаме следният бутон в xml-a:
```xml
<Button
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:text="Joker"
  android:onClick="jokerClicked"/>
```
Когато се кликне ще се извиква функцията ```jokerClicked``` от активитито:
```java
public void jokerClicked(View v) {
  v.setEnabled(false);
}
```
Така когато се кликне бутонът той ще се деактивира и няма да може да се клика повече.

Сега остава да сменим картинката. Това, разбира се, ще направим със селектор. Към xml-а на бутона ще добавим ```android:background="@drawable/joker_selector"```. Това ще е селектора, който ще избира фон в зависимост от това дали бутонът е активен или не (enabled е true или false).
В drawable във файла ```joker_selector.xml``` ще сложим следния код, който върши тази работи
```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

  <item android:drawable="@drawable/joker_enabled"
      android:state_enabled="true"></item>

  <item android:drawable="@drawable/joker_disabled"
      android:state_enabled="false"></item>

</selector>
```
Тук се предполага, че имаме две подходящи картинки joker_enabled и joker_disabled - за активен и неактивен бутон.


# Как да организираме въпросите
След като се оправим с дизайна ще дойде въпросът как да организираме въпросите така, че работим с тях лесно и удобно. Сега е моментът да се върнем към първоначалните изисквания, които имахме:

1. Въпросите да са разделени в три категории - лесни (от където ще се избират въпроси от 1 до 5), средни (за въпроски от 5 до 10) и трудни (за въпроси от 10 до 15).
2. Въпросите от всяка категория се избират по случаен начин
3. Добавянето на нови въпроси да става лесно.

Има много начини, по които можем да организираме кода, който се занимава с въпросите. Тук ще се спрем на един от най-ефективните от тях.

## Класове за въпрос и отговор

За да можем да работим лесно с въпросите и отговорите, ще ги представим като класове. 
Първо нека направим класа Answer, който ще съдържа информацията за един _отговор_. Каква информация ни е нужна за отговор? - текстът на отговора и дали той е верен или грешен.
```java
public class Answer {
    private int score;
    private String text;
}

```

В член променливата text ще пазим текста на въпроса, а в score - колко точки носи избирането на този въпрос (ако е грешен ще носи 0 точки, ако е верен 1).
И двете променливи сме маркирали като ```private```, защото не искаме други класове да ги променят (така намаляваме възможността за грешки в програмата ни).

За да може този клас да се използва, трябва да има конструктор (фукнция, която създава обекта) и get-eри (функции, които ни дават достъп до променливите). Добавянето на конструкури и гетери в Android Studio става лесно чрез клавишната комбинация Alt+Insert.
С добавените get-ери и set-ери класът ще изглежда така:

```java
public class Answer {
    
    private int score;
    private String text;

    public Answer(int score, String text) {
        this.score = score;
        this.text = text;
    }

    public int getScore() {
        return score;
    }

    public String getText() {
        return text;
    }
}
```

Сега ни трябва още един клас ```Question```, който ще обединява всичко, което ни интересува относно един въпрос. Какво е то? - текста на въпроса и четирите възможни отговора:

```java
public class Question {

    private String text;

    private Answer anwers[] = new Answer[4];
}
```
За да не правим четири променливи за всеки от отговорите, използваме масив от 4 елемента. Това има още едно предимство - ако в някой момент искаме да променим играта, така че всики въпрос да има 5 възможно отговора, ще можем да го направим много лесно.

Отново добавяме конструктур и geter функции с ```Alt+Insert```.


## Четене на въпроса от XML
В начолото имахме изискването въпросите да се сменят и добавят лесно. Точно за това ще използваме XML.
Защо? Защото XML-а е удобен. Така въпросите ще изглеждат по следния начин:

```xml
<questions>
    <question>
        <description>Колко е 2+3?</description>
        <answer score="1">5</answer>
        <answer score="0">14</answer>
        <answer score="0">3.151528</answer>
        <answer score="0">0</answer>
    </question>
    <question>
        <description>Защо ползваме XML? </description>
        <answer score="1">Защото работата с информация в тестов формат е удобна</answer>
        <answer score="0">За да ни е по-трудно на школата</answer>
        <answer score="0">Какво ползваме?!? </answer>
        <answer score="0">Не знам</answer>
    </question>
</questions>
```
Освен това всички въпроси и отговори ще се намират на едно място, в един файл и в този файл ще има само въпроси.
Използването на XML има множество предимства, които ще виждаме завбъдеще, но все още е рано да отбелязваме.


### PullParser

За да използваме удобствата на XML ще трябва да направим допълнителен клас, който превежда XML-а в Java код.
Прието е такива класове да се наричат parser-и. Можем да си мислим за тях като преводачи. А самия процес на "превежщането" често се нарича ```parsing```.

Ще създаздем нов клас ```QuestionsParser```, който да изполнява тази задача.
[Кода на Parser-а можете да видите тук](./app/src/main/java/com/marinshalamanov/stanibogat/QuestionsParser.java)


### Как да използваме QuestionsParser?

Следният код прочита xml файла ```res/xml/easy_questions.xml``` и създава масива от въпроси ```questions```.

```java
Question[] questions = null; // създаваме празен масив за въпросите

try {
    // Взимаме файла res/xml/easy_questions.xml и го записваме в променливата parser
    XmlResourceParser parser=getResources().getXml(R.xml.easy_questions); 
    
    // създаваме нов QuestionsParser и го записваме в променливата quizTextParser
    QuestionsParser quizTextParser = new QuestionsParser();
    
    // превеждаме файла (parser) и преведеното записваме в масива questions
    questions = quizTextParser.parseXml(parser);

} catch (XmlPullParserException | IOException | Resources.NotFoundException e) { // ако се появи грешка

    // изписваме в грешката в логовете
    Log.e (getClass().toString(), "exception during parsing", e);
}
```

Такъв код е подходящо да бъде в onCreate метода на нашето Activity, за да може при всяко негово стартиране да се заредят въпросите.


# Как да споделяме в социални медии

Механизъмът са споделяне е следния - правим intent за споделяне и го изпълняваме. Така Андроид системата ще покаже диалогов прозорец с въпрос "С кое проиложение искаш да споделиш?" и потребителя ще избере от възможните. Примерен код:

```java
Intent intent = new Intent();

intent.setType("text/plain");
intent.putExtra(Intent.EXTRA_TEXT, "here comets the text that'll be shared");
startActivity(Intent.createChooser(intent, "Share"));
```
